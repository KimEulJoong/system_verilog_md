# Filter

## fir_filter.sv
```SystemVerilog
`timescale 1ns/1ps

module fir_filter (
    input  logic clk,
    input  logic rst_n,
    input  logic signed [6:0] din,         // Q1.6 입력
    output logic signed [6:0] dout         // Q1.6 출력
);

    parameter TAP = 33;

    // Q1.8 fixed-point RRC coefficients (signed 9-bit)
    localparam signed [8:0] COEFF [0:TAP-1] = '{
         0,  -1,   1,   0,  -1,   2,   0,  -2,   2,   0,
        -6,   8,  10, -28, -14, 111, 196, 111, -14, -28,
        10,   8,  -6,   0,   2,  -2,   0,   2,  -1,   0,
         1,  -1,   0
    };

    // Shift register for input samples (Q1.6)
    logic signed [6:0] shift_reg [0:TAP-1];

    // Accumulator: 7b * 9b = 16b → sum → 32b 정수
    logic signed [31:0] acc;

    // Intermediate output before final FF
    logic signed [6:0] dout_next;

    // Shift register: 입력 샘플 이동
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < TAP; i++) shift_reg[i] <= 0;
        end else begin
            shift_reg[0] <= din;
            for (int i = 1; i < TAP; i++)
                shift_reg[i] <= shift_reg[i - 1];
        end
    end

    // FIR 연산 (multiply-accumulate) — Q1.6 × Q1.8 = Q2.14 누적
    always_comb begin
        acc = 0;
        for (int i = 0; i < TAP; i++) begin
            logic signed [15:0] mult;
            mult = $signed(shift_reg[i]) * $signed(COEFF[i]);  // Q1.6 * Q1.8 = Q2.14
            acc += mult;   //delay 심한 방식 -> 병렬로 수정 필요
        end
    end

    // 라운딩 및 클리핑: Q2.14 → Q1.6
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            dout_next <= 0;
        end else begin
            logic signed [15:0] rounded;
            rounded = acc >>> 8;  // +0.5 (128) for rounding → shift 8 → Q1.6

            // Saturation (Clip to [-64, +63])
            if (rounded > 63)
                dout_next <= 63;
            else if (rounded < -64)
                dout_next <= -64;
            else
                dout_next <= rounded[6:0];
        end
    end

    // 최종 출력 FF (타이밍 안정용)
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            dout <= 0;
        else
            dout <= dout_next;
    end
endmodule
```

## tb_fir_filter.sv
```SystemVerilog
`timescale 1ns/1ps

module tb_fir_filter;

    logic clk, rst_n;
    logic signed [6:0] din;
    logic signed [6:0] dout;

    fir_filter dut (
        .clk(clk),
        .rst_n(rst_n),
        .din(din),
        .dout(dout)
    );

    // Clock
    initial clk = 0;
    always #5 clk = ~clk;

    // File handles
    integer fd_in, fd_out, r;
    int cycle = 0;
    int max_print = 46500;  // 전체의 절반 정도만 화면에 출력

    initial begin
        $dumpfile("tb_fir_filter.vcd");
        $dumpvars(0, tb_fir_filter);

        rst_n = 0;
        din = 0;
        #20 rst_n = 1;

        fd_in = $fopen("input_vector.txt", "r");
        fd_out = $fopen("output_vector.txt", "w");

        if (fd_in == 0 || fd_out == 0) begin
            $display("❌ 파일 열기 실패!");
            $finish;
        end

        while (!$feof(fd_in)) begin
            r = $fscanf(fd_in, "%d\n", din);
            #10;
            $fwrite(fd_out, "%0d\n", dout);
            if (cycle < max_print)
                $display("[%0t ns] din = %0d, dout = %0d", $time, din, dout);
            cycle++;
        end

        $fclose(fd_in);
        $fclose(fd_out);
        $display("✅ 총 %0d개의 벡터 처리 완료", cycle);
        $display("📂 output_vector.txt 파일에서 전체 출력 결과 확인 가능");
        #100;
        $finish;
    end

endmodule

```