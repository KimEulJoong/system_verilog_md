## shift_register.v

```verilog
`timescale 1ns/10ps

module shift_reg #(parameter WIDTH = 7)(
        input clk,
        input rstn,

        input signed [WIDTH-1:0] data_in,
        output reg signed [WIDTH-1:0] data_out
);

reg signed [WIDTH-1:0] shift_din [32:0];
integer i;
always@(posedge clk or negedge rstn) begin
        if(~rstn) begin
                for(i=32; i>=0; i=i-1) begin
                        shift_din[i] <= 0;
                end
        end
        else begin
                for(i=32; i>0; i=i-1) begin
                        shift_din[i] <= shift_din[i-1];
                end
                        shift_din[0] <= data_in;
                end
end

wire [WIDTH-1:0] shift_dout;
assign shift_dout = shift_din[8];

reg[5:0] count;
always@(posedge clk or negedge rstn) begin
        if(~rstn)begin
                count <= 4'b0;
        end
        else begin
                count <= count + 4'b1;
        end
end

reg[WIDTH-1:0] ref_data;
always@(posedge clk or negedge rstn) begin
        if(~rstn)begin
                ref_data <= 4'b0;
        end
        else if (count==6'd1)begin
                ref_data <= data_in;
        end
end

reg [WIDTH-1:0] data_out;
always@(posedge clk or negedge rstn) begin
        if(~rstn)begin
                data_out <= 4'b0;
        end
        else if (count==6'd10)begin
                data_out <= shift_dout;
        end
end


reg shift_op;
always@(posedge clk or negedge rstn) begin
        if(~rstn)begin
                shift_op <= 1'b0;
        end
        else if (count==6'd10)begin
                if(shift_dout == ref_data)
                        shift_op <= 1'b0;
                else
                        shift_op <= 1'b1;
        end
end

reg error_ind;
always@(posedge clk or negedge rstn)begin
        if(~rstn)begin
                error_ind <= 1'b0;
        end
        else if (count==6'd10) begin
                if(shift_dout ==3)
                        error_ind <= 1'b0;
                else
                        error_ind <= 1'b1;
        end
end
endmodule
```

### 코드 설명 :
- data_in -> (shift_din / shift_dout) : 33칸 짜리 f/f -> data_out
- clk 마다 count해서 count =10 에서 data_out <= shift_dout

----------

## simulation img
### 1. #25
<img src="./img/250714_delay25.png"><br>
- tb 에서 #25을 주어 negedge clk에 data_in이 들어가면, 그 다음 posedge clk에서 shift_din이 업데이트 하게 되고 count 10 일때 shift_dout은 3이다.

### 1. #20
<img src="./img/250714_delay20.png"><br>
- tb 에서 #20을 주어 posedge clk에 정확히 data_in이 들어가면 즉시 shift_din이 업데이트 되어 #25와 비교했을 때 shift_din이 한칸씩 왼쪽으로(빠르게) 밀리게 되었다.
  따라서 count 10일때 shift_dout은 1이다.

--------

## setup time, hold time
### 타이밍 에러
- gate level 에서 타이밍 에러 원인을 찾는다
### setup time
- setup violation 발생 : 
  - setup time을 지키지 못한 것
  - propagation delay 를 줄일 수 있으면 best
    - 50Mhz clk을 사용한다면 이 clk은 20ns 이다
    - if) setup time < propagation delay time => 문제 발생
    - 해결 방안 : 파이프라인을 박아 넣어 (F/F으로 만들어) propagation delay를 줄이자

### hold time
- hold violation 발생 :
  - hold time을 지키지 못한 것
  - delay를 줘야한다
    - 해결 방안 : 버퍼 추가